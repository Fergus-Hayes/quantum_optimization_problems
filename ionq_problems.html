<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Fergus Hayes">

<title>IonQ Application Team’s Homework</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="ionq_problems_files/libs/clipboard/clipboard.min.js"></script>
<script src="ionq_problems_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="ionq_problems_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="ionq_problems_files/libs/quarto-html/popper.min.js"></script>
<script src="ionq_problems_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ionq_problems_files/libs/quarto-html/anchor.min.js"></script>
<link href="ionq_problems_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ionq_problems_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ionq_problems_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ionq_problems_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ionq_problems_files/libs/bootstrap/bootstrap-fc12481b278b721264e35481c7c3a605.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">IonQ Application Team’s Homework</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Fergus Hayes </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="strategy" class="level1">
<h1>Strategy</h1>
<blockquote class="blockquote">
<ol type="1">
<li>According to you, in which application area will we see the first demonstration of quantum advantage and why? Try to take into account the latest advances in algorithm and hardware development when presenting your answer.</li>
</ol>
</blockquote>
<section id="quantum-advantage" class="level2">
<h2 class="anchored" data-anchor-id="quantum-advantage">Quantum advantage:</h2>
<p>First, I find it is necessary to lay out my criteria for a quantum computing application to meet before achieving quantum advantage:</p>
<ul>
<li>It is executed on available quantum hardware,</li>
<li>Its solution can be well verified,</li>
<li>The solution provided requires less computation than the state-of-the-art classical method for the same accuracy and solution goodness.</li>
</ul>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications:</h2>
<p>With these three criteria, I will analyse the leading candidates for quantum advantage, namely: sampling, quantum chemistry, simulation and optimization.</p>
<section id="sampling" class="level3">
<h3 class="anchored" data-anchor-id="sampling">Sampling:</h3>
<p>It is known that sampling from particular probability distributions is computationally challenging for classical computers, while quantum computers are well suited to such tasks due to their probabilistic nature. Samples produced from random quantum circuits uniformly cover the Hilbert space and therefore the dimensionality of the target distribution scales exponentially with system size. Sampling problems that are infeasible on a classical computer have been performed on Google’s Sycamore (<span class="citation" data-cites="arute2019quantum">Arute et al. (<a href="#ref-arute2019quantum" role="doc-biblioref">2019</a>)</span>, <span class="citation" data-cites="morvan2024phase">Morvan et al. (<a href="#ref-morvan2024phase" role="doc-biblioref">2024</a>)</span>) and the Quantinuum’s H2 device (<span class="citation" data-cites="decross2025computational">DeCross et al. (<a href="#ref-decross2025computational" role="doc-biblioref">2025</a>)</span>). However, the presence of noise in quantum hardware restricts the sampling to subspaces of the Hilbert space and remove this guarantee of quantum advantage, as discussed in <span class="citation" data-cites="aharonov2023polynomial">Aharonov et al. (<a href="#ref-aharonov2023polynomial" role="doc-biblioref">2023</a>)</span>. Unfortunately, directly comparing the output distribution to that of a Thomas-Porter distribution (produced from the uniform sampling over the Hilbert space) is computationally diffucult, and calculating measures to determine if it is ‘close enough’ leave room for ambiguity.</p>
</section>
<section id="quantum-chemistry" class="level3">
<h3 class="anchored" data-anchor-id="quantum-chemistry">Quantum chemistry:</h3>
<p>Determining the ground state energy of a given Hamiltonian is an important problem in chemistry and physics. Due to the exponential size of the energy landscape, classical computers are limited to analysing very small system sizes. There has been much interest into the application of the variational quantum eigensolver (VQE) algorithms to perform this task (<span class="citation" data-cites="peruzzo2014variational">Peruzzo et al. (<a href="#ref-peruzzo2014variational" role="doc-biblioref">2014</a>)</span>). This variational approach allows for its application on near-term noisy devices. State-of-the-art methods, like the sample-based Krylov quantum diagonalization algorithm, have been shown to converge to a solution in polynomial time for certain Hamiltonians (<span class="citation" data-cites="yu2501quantum">Yu et al. (<a href="#ref-yu2501quantum" role="doc-biblioref">2025</a>)</span>). The energy of the output solution can be calculated and verified against that produced from a classical method. However, all VQE methods rely on the assumption that they have access to an initial state that has some degree of overlap with the ground state. The idea of <em>warm starting</em> problems of optimisation in this way is not singular, however there is no guarantee obtaining such approximate ground state solutions efficiently is computationally feasible for all problems in chemistry, and proves to be a roadblock for many real applications of VQE.</p>
</section>
<section id="simulation" class="level3">
<h3 class="anchored" data-anchor-id="simulation">Simulation:</h3>
<p>Using quantum computers to simulate target Hamiltonians was the first proposed use of the devices. To explore the time evolution of a complex quantum system, it is reasonable to construct an approximate Hamiltonian in a controlled environment, and to analyse the observables it produces. The better that the approximation to the quantum systems true Hamiltonian is made, the better the simulation becomes. Exact diagonalization of the system becomes quickly infeasible on a classical computer, and are limited in long time evolutions of Hamiltonians when pushed to extreme conditions such as the approach of a phase transition. This task is especially well suited to near-term analog quantum computers that evolve an inbuilt Hamiltonian to perform their computation, and therefore allow for simulations of Hamiltonians that their native Hamiltonian can well approximate (<span class="citation" data-cites="choi2016exploring">Choi et al. (<a href="#ref-choi2016exploring" role="doc-biblioref">2016</a>)</span> <span class="citation" data-cites="king2024computational">King et al. (<a href="#ref-king2024computational" role="doc-biblioref">2024</a>)</span> <span class="citation" data-cites="andersen2025thermalization">Andersen et al. (<a href="#ref-andersen2025thermalization" role="doc-biblioref">2025</a>)</span>), but can also be approximated on digital hardware through Trotterization (<span class="citation" data-cites="kim2023evidence">Kim et al. (<a href="#ref-kim2023evidence" role="doc-biblioref">2023</a>)</span>, plus see technical problem 1). The problem with quantum simulation is similar to that of sampling, where the presence of noise in the quantum device introduces ambiguity to the output, and verification of the results becomes challenging. The effects of this noise can be somewhat reduced with current error mitigation techniques, as demonstrated in <span class="citation" data-cites="kim2023evidence">Kim et al. (<a href="#ref-kim2023evidence" role="doc-biblioref">2023</a>)</span>. However, this only applies to regimes where the noise is well behaved and before it dominates observables.</p>
</section>
<section id="optimisation" class="level3">
<h3 class="anchored" data-anchor-id="optimisation">Optimisation:</h3>
<p>Combinatorial optimisation problems are ubiquitous in industry and are exponential in solution space to problem size. Solutions to optimization problems can be easily verified once produced, allowing for a straightforward comparison between quantum and classical methods. Both classical and quantum algorithms that guarantee exact solutions are prohibited due to the NP-hardness of the problems and instead rely on heuristic methods. This allows room for quantum advantage to be potentially demonstrated for optimization problems on a case-by-case basis. QAOA is a variational heuristic approach, making it well suited to noisy near-term devices <span class="citation" data-cites="farhi2014quantum">Farhi, Goldstone, and Gutmann (<a href="#ref-farhi2014quantum" role="doc-biblioref">2014</a>)</span>. Optimization problems such as finding the maximum independent set are well suited to the native Hamiltonian of neutral atom devices, where it has been identified regimes for which state-of-the-art classical optimization methods fail <span class="citation" data-cites="cazals2025identifying">Cazals et al. (<a href="#ref-cazals2025identifying" role="doc-biblioref">2025</a>)</span>. While it was identified that system sizes towards 1000 would be required before advantage could be reached, this is in the projection of current hardware development.</p>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion:</h2>
<p>From the points discussed above, I believe that convincing quantum advantage is most achievable on near-term devices through optimisation problems. This is due to the applicability of such problems to current hardware, the ease at which solutions can be verified, and the potential of algorithms such as QAOA to challenge current classical methods despite hardware noise (see <span class="citation" data-cites="zhou2020quantum">Zhou et al. (<a href="#ref-zhou2020quantum" role="doc-biblioref">2020</a>)</span> and technical problem 3). While heuristic quantum methods like QAOA do not guarantee that classical methods cannot exist that outperform them, the vast number of industrially relevant optimization problems offer much potential for quantum advantage to be sought. Additionally, classical optimisation algorithms for such problems have been studied extensively due to their demand. Therefore any improvements over current classical methods would likely be a long-standing demonstration of quantum advantage, and provide immediate utility in industry.</p>
<p>Applications in sampling and simulation may become more favourable avenues for quantum advantage in coming years, with the progress of noise-reduced hardware and error correction to bring about fault-tolerant quantum computing, as demonstrated for random circuit sampling in <span class="citation" data-cites="bluvstein2024logical">Bluvstein et al. (<a href="#ref-bluvstein2024logical" role="doc-biblioref">2024</a>)</span>. With a reduction in the effects of noise, the solutions provided to problems in sampling and simulation will become more trustworthy and remove the ambiguity in their verification.</p>
<p>I therefore believe that a roadmap to quantum advantage should include both applications in optimization and future plans of fault-tolerant applications through the development of error correction methods.</p>
</section>
</section>
<section id="technical" class="level1">
<h1>Technical</h1>
<blockquote class="blockquote">
<ol type="1">
<li>Consider the Heisenberg model on a 1D lattice with nearest neighbor interactions. Construct a circuit that allows you to do a Trotterized time-evolution of this Hamiltonian using single qubit rotations and CNOT gates. Make it as efficient in the number of 2-qubit gates and circuit depth as you can. Then use a quantum software framework of your choice (for example, Qiskit or Cirq) to implement this and show the code.</li>
</ol>
</blockquote>
<p>I consider a general 1D Heiseinberg model Hamiltonian with all nearest-neighbour coupling (<span class="math inline">\(J_x\)</span>, <span class="math inline">\(J_y\)</span>, <span class="math inline">\(J_z\)</span>) and field (<span class="math inline">\(h_x\)</span>, <span class="math inline">\(h_y\)</span>, <span class="math inline">\(h_z\)</span>) terms of the form:</p>
<p><span class="math display">\[
H = \sum^{n-2}_{i=0} (J_x\hat{\sigma}^x_i\hat{\sigma}^x_{i+1} + J_y\hat{\sigma}^y_i\hat{\sigma}^y_{i+1} + J_z\hat{\sigma}^z_i\hat{\sigma}^z_{i+1}) + \sum^{n-1}_{j}(h_x\hat{\sigma}^x_i + h_y\hat{\sigma}^y_i + h_z\hat{\sigma}^z_i).
\]</span></p>
<p>To approximate this, I assume a second-order Suzuki–Trotter expansion. The individual coupling terms can be broken down into RXX, RYY and RZZ gates that each require 2 CNOT gates each. The edges of the graph associated with 1D chain has two colours, corresponding to odd and even sites, and can therefore be treated with two-qubit gates independently allowing for their application to be parallelized.</p>
<div id="14d00951" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.circuit <span class="im">import</span> QuantumCircuit, QuantumRegister, Parameter</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.quantum_info <span class="im">import</span> Statevector</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tenpy.models.spins <span class="im">import</span> SpinChain</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tenpy.networks.mps <span class="im">import</span> MPS</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tenpy.algorithms.tebd <span class="im">import</span> TEBDEngine</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tenpy.algorithms.exact_diag <span class="im">import</span> get_full_wavefunction</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>matplotlib.rcParams[<span class="st">'mathtext.fontset'</span>] <span class="op">=</span> <span class="st">'stix'</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>matplotlib.rcParams[<span class="st">'font.family'</span>] <span class="op">=</span> <span class="st">'STIXGeneral'</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>width<span class="op">=</span><span class="fl">0.75</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>color<span class="op">=</span><span class="st">'black'</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>fontsize<span class="op">=</span><span class="dv">28</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>ticksize<span class="op">=</span><span class="dv">22</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0056de85" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> RXX_gate(circ, q1, q2, theta):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    circ:    QuantumCircuit object to apply RXX gate to</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    q1:      First qubit</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    q2:      Second qubit</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    theta:   Rotation angle</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    returns: QuantumCircuit object with RXX gate applied to qubits q1 and q2</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    circ.h(q1)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    circ.h(q2)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    circ.cx(q1, q2) <span class="co"># First CNOT</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    circ.rz(theta, q2)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    circ.cx(q1, q2) <span class="co"># Second CNOT</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    circ.h(q1)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    circ.h(q2)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circ</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> RYY_gate(circ, q1, q2, theta):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">    circ:    QuantumCircuit object to apply RYY gate to</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">    q1:      First qubit</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co">    q2:      Second qubit</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co">    theta:   Rotation angle</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co">    returns: QuantumCircuit object with RYY gate applied to qubits q1 and q2</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    circ.sx(q1).inverse()</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    circ.sx(q2).inverse()</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    circ.cx(q1, q2) <span class="co"># First CNOT</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    circ.rz(theta, q2)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    circ.cx(q1, q2) <span class="co"># Second CNOT</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    circ.sx(q1)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    circ.sx(q2)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circ</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> RZZ_gate(circ, q1, q2, theta):</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co">    circ:    QuantumCircuit object to apply RZZ gate to</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co">    q1:      First qubit</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co">    q2:      Second qubit</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">    theta:   Rotation angle</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="co">    returns: QuantumCircuit object with RZZ gate applied to qubits q1 and q2</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    circ.cx(q1, q2) <span class="co"># First CNOT</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    circ.rz(theta, q2)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    circ.cx(q1, q2) <span class="co"># Second CNOT</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circ</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> HModel_trot(circ, qreg, T, J, h, nstep<span class="op">=</span><span class="dv">1</span>, PBC<span class="op">=</span><span class="va">True</span>, wrap<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>                inverse<span class="op">=</span><span class="va">False</span>, label<span class="op">=</span><span class="st">'Hberg trot'</span>):</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="co">    A quantum circuit approximating a 1D nearest-neighbour Heisenberg model </span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a><span class="co">    using a second-order Suzuki–Trotte decomposition.</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="co">    circ:    QuantumCircuit object that the Trotterized Heisenberg model is </span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="co">             applied to.</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="co">    qreg:    QuantumRegister object of n qubits.</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a><span class="co">    T:       Evolution time.</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="co">    J:       Coupling terms of Hamiltonian that are either a list [Jx, Jy, Jz] </span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="co">             or a float such that J=Jx=Jy=Jz.</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a><span class="co">    h:       Field strength terms of Hamiltonian that are either a list </span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a><span class="co">             [hx, hy, hz] or a float such that hx=hy=0 and h=hz.</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a><span class="co">    nstep:   Number of steps to the Trotterization (int) default nstep=1.</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a><span class="co">    PBC:     Apply periodic bounadry conditions (bool) default PBC=True.</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a><span class="co">    wrap:    Convert output into Gate object (bool) default wrap=False.</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a><span class="co">    inverse: Return inverted Gate object (bool) default inverse=False.</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a><span class="co">    label:   Label to name wrapped gate (str) default label='Hberg trot'.</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="co">    returns: QuantumCircuit object with RZZ gate applied to qubits q1 and q2 </span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="co">             or Gate object if wrap=True.</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(J)<span class="op">!=</span><span class="dv">3</span>:</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">'Coupling terms J must be a single digit '</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>            <span class="st">'or a list of three values.'</span>)</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>            Jx, Jy, Jz <span class="op">=</span> J</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">TypeError</span>:</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>        Jx, Jy, Jz <span class="op">=</span> J, J, J</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(h)<span class="op">!=</span><span class="dv">3</span>:</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">'Field strength terms h must be a single digit '</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>            <span class="st">'or a list of three values.'</span>)</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>            hx, hy, hz <span class="op">=</span> h</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">TypeError</span>:</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>        hx, hy, hz <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>, h</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(qreg)</span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> inverse:</span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>        wrap <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> wrap: </span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If wrap, define new QuantumRegister and QuantumCircuit </span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># to apply operations to</span></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>        qreg <span class="op">=</span> QuantumRegister(n, <span class="st">'qreg'</span>)</span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>        circ <span class="op">=</span> QuantumCircuit(qreg)</span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> <span class="op">-</span><span class="bu">int</span>(PBC)</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> np.arange(nstep): </span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Loop through all trotter steps for the first half of the T</span></span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>        <span class="co"># rotter application with 1/2 angles</span></span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> np.arange(start,n<span class="op">-</span><span class="dv">1</span>)[::<span class="dv">2</span>]: </span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># First apply all gates of odd(even) sites </span></span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>            <span class="co"># (depending on if PBC=True)</span></span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jx<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RXX_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jx<span class="op">/</span>nstep)</span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jy<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RYY_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jy<span class="op">/</span>nstep)</span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jz<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RZZ_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jz<span class="op">/</span>nstep)</span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> np.arange(start<span class="op">+</span><span class="dv">1</span>,n<span class="op">-</span><span class="dv">1</span>)[::<span class="dv">2</span>]: </span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Then apply all gates of even(odd) sites</span></span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jx<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RXX_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jx<span class="op">/</span>nstep)</span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jy<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RYY_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jy<span class="op">/</span>nstep)</span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jz<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RZZ_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jz<span class="op">/</span>nstep)</span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(start,n<span class="op">-</span><span class="dv">1</span>): <span class="co"># Loop through single qubit operations</span></span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> hx<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>            circ.rx(T<span class="op">*</span>hx, qreg[i])</span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> hy<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>            circ.ry(T<span class="op">*</span>hy, qreg[i])</span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> hz<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>            circ.rz(<span class="dv">2</span><span class="op">*</span>T<span class="op">*</span>hz, qreg[i])</span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> hy<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>            circ.ry(T<span class="op">*</span>hy, qreg[i])</span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> hx<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>            circ.rx(T<span class="op">*</span>hx, qreg[i])</span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> np.arange(nstep): </span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Loop through all trotter steps for the second half of the </span></span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Trotter application with 1/2 angles</span></span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> np.arange(start<span class="op">+</span><span class="dv">1</span>,n<span class="op">-</span><span class="dv">1</span>)[::<span class="dv">2</span>]: </span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply all gates of even(odd) sites</span></span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jz<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RZZ_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jz<span class="op">/</span>nstep)</span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jy<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RYY_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jy<span class="op">/</span>nstep)</span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jx<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RXX_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jx<span class="op">/</span>nstep)</span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> np.arange(start,n<span class="op">-</span><span class="dv">1</span>)[::<span class="dv">2</span>]: </span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Then apply all gates of odd(even) sites</span></span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jz<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RZZ_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jz<span class="op">/</span>nstep)</span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jy<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-160"><a href="#cb2-160" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RYY_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jy<span class="op">/</span>nstep)</span>
<span id="cb2-161"><a href="#cb2-161" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Jx<span class="op">!=</span><span class="fl">0.</span>:</span>
<span id="cb2-162"><a href="#cb2-162" aria-hidden="true" tabindex="-1"></a>                circ <span class="op">=</span> RXX_gate(circ, qreg[i], qreg[i<span class="op">+</span><span class="dv">1</span>], T<span class="op">*</span>Jx<span class="op">/</span>nstep)</span>
<span id="cb2-163"><a href="#cb2-163" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-164"><a href="#cb2-164" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> wrap:</span>
<span id="cb2-165"><a href="#cb2-165" aria-hidden="true" tabindex="-1"></a>        circ <span class="op">=</span> circ.to_gate()</span>
<span id="cb2-166"><a href="#cb2-166" aria-hidden="true" tabindex="-1"></a>        circ.label <span class="op">=</span> label</span>
<span id="cb2-167"><a href="#cb2-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-168"><a href="#cb2-168" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> inverse:</span>
<span id="cb2-169"><a href="#cb2-169" aria-hidden="true" tabindex="-1"></a>        circ <span class="op">=</span> circ.inverse()</span>
<span id="cb2-170"><a href="#cb2-170" aria-hidden="true" tabindex="-1"></a>        circ.label <span class="op">=</span> label<span class="op">+</span><span class="st">'</span><span class="er">\</span><span class="st">dag'</span></span>
<span id="cb2-171"><a href="#cb2-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-172"><a href="#cb2-172" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circ</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<ol start="2" type="1">
<li>Consider the QAOA algorithm applied to the MaxCut problem on 3-regular graphs. Suppose you have a square lattice of qubits with nearest neighbor connectivity. Describe an algorithm and write commented pseudocode that allows you to map the qubits in the QAOA circuit to the physical qubit layout and schedule the circuit in the most efficient way you can come up with. Do a theoretical or numerical analysis of the time complexity of the schedule.</li>
</ol>
</blockquote>
<p>We have a 3-regular problem graph <span class="math inline">\(G\)</span> with edges <span class="math inline">\(E\)</span> and <span class="math inline">\(n\)</span> vertices <span class="math inline">\(V\)</span>, and a square lattice of spacing <span class="math inline">\(a\)</span> and <span class="math inline">\(L\times L=N\)</span> qubits, where <span class="math inline">\(N\ge n\)</span> with nearest neighbour interactions, described by graph <span class="math inline">\(G'\)</span>.</p>
<p>First, we map the graph vertices to the qubits in the lattice. This should be done through a breadth-first search algorithm to minimize the number of edges between vertices that are assigned between non-local (beyond nearest-neighbour) qubits. If <span class="math inline">\(G\)</span> is a planar graph, then the embedding becomes trivial as the connectivity of the nearest neighbour square lattice is greater than the problem graph. However, if we have edges between vertices that are non-local that we wish to embed, we will require a subroutine to the QAOA. If we have two non-local qubits that correspond to two vertices that share an edge, we can apply a chain of SWAP gates between neighbouring qubits to allow for connections between the two qubits. The furthest two qubits would require <span class="math inline">\(2L\)</span> SWAP gates to connect one another. These chains of SWAP gates must be applied in succession, but SWAP gate chains for different non-local connections may be done in parallel. The SWAP gate application is inverted with the same number of operations. The application of the problem Hamiltonian in the QAOA algorithm requires two-qubit gates, the number of which scales with the number of graph edges. Edges that do not share vertices can be applied in parallel, so the maximum required two-qubit depth of the QAOA circuit is equal to the chromatic index of the graph, which is a maximum of 4. The assignment of edges to each of the colours, in order to parallelize this process, can be done as a preprocessing step.</p>
<pre><code>--------------------------------------------------------------------------------------
# Return a dictionary linking vertices of G to corresponding lattice positions
mapping = breadth_first_search(G, G')

# Returns a list of arrays of all edges with the same colour
edge_colorings = cuthill_mckee_algorithm(G)

# Define an empty list to save circuit to
circuit = []

for i in p: # Loop through assigned number of layers p

    # Append to circuit list the mixing Hamiltonian
    circuit.append(qaoa_mixing_hamiltonian(beta[i]))

    for edges_of_color in edge_colorings: # Loop through edge colours

        for edge in edges_of_color: # Loop through each edge (executed in parallel)

            # dist() returns the Euclidean distance between two points
            if dist(mapping[edge[0]]-mapping[edge[1]])&gt;a:

                # Determine the chain of SWAP gates between the two points
                swap_gate_chain = shortest_swap_path(mapping[edge])
                circuit.append(swap_gate_chain)

            # Append to circuit the problem Hamiltonian
            circuit.append(qaoa_problem_hamiltonian(edge, gamma[i]))

            # Invert the SWAP gate chain application
            if dist(mapping[edge[0]]-mapping[edge[1]])&gt;a:
                circuit.append(swap_gate_chain.inverse)

--------------------------------------------------------------------------------------</code></pre>
<p>The computational cost of the mapping (assuming a breadth-first search eg. Cuthill-McKee algorithm <span class="citation" data-cites="cuthill1969reducing">Cuthill and McKee (<a href="#ref-cuthill1969reducing" role="doc-biblioref">1969</a>)</span>) scales <span class="math inline">\(O(|E|+|V|)=O(n)\)</span>. The Misra &amp; Gries edge-coloring algorithm can be performed in <span class="math inline">\(O(|E|)=O(n)\)</span> steps according to <span class="citation" data-cites="assadi2025vizing">Assadi et al. (<a href="#ref-assadi2025vizing" role="doc-biblioref">2025</a>)</span>. Each QAOA layer will consist of two applications of SWAP gate chains, which (if we assume <span class="math inline">\(n=N\)</span>), is upper-bounded by <span class="math inline">\(O(\sqrt{n})\)</span>. The problem Hamiltonian application has constant depth of max 4. Therefore the computational cost of <span class="math inline">\(p\)</span> layers of QAOA scales <span class="math inline">\(O(p \sqrt{n})\)</span>.</p>
<blockquote class="blockquote">
<ol start="3" type="1">
<li>Consider the QAOA algorithm. For uniform graphs, there is numerical evidence (https://arxiv.org/pdf/1812.01041.pdf) that the approximation ratio will increase exponentially with the number of layers in the algorithm. Assuming this is true, let’s say you have a quantum computer in which depolarizing noise affects each 2-qubit gate. Analyze how the approximation ratio behaves as a function of the strength of the noise and the number of layers.</li>
</ol>
</blockquote>
<p>A two-qubit depolarizing noise channel introduces some probability <span class="math inline">\(\lambda\)</span> of applying one of 15 Pauli errors for each 2-qubit gate implementation. If we apply this to every gate in the QAOA application this will evolve the state towards the maximally mixed state over successive layers at a rate <span class="math inline">\(R\)</span> dependent on <span class="math inline">\(\lambda\)</span>. Each problem Hamiltonian application applies a number of two-qubit gates proportional to the number of edges of the problem graph, which will scale with the system size <span class="math inline">\(n\)</span>. The paper <span class="citation" data-cites="zhou2020quantum">Zhou et al. (<a href="#ref-zhou2020quantum" role="doc-biblioref">2020</a>)</span> numerically fits the approximate ratio <span class="math inline">\(r\)</span> and number of layer relation for the unweighted graph types with an exponential fit:</p>
<p><span class="math display">\[
r(p) = 1-r_{0}e^{-\alpha p},
\]</span></p>
<p>where <span class="math inline">\(r_0\)</span> is the approximate ratio at <span class="math inline">\(p=0\)</span> which is equal to the average approximate ratio from drawing uniform solutions to the problem Hamiltonian, and <span class="math inline">\(\alpha\)</span> is the nuermically fitted slope. Similarly, the approximate ratio resulting from the maximally mixed state that the noisy system approaches at <span class="math inline">\(p\rightarrow \infty\)</span> is also equal to <span class="math inline">\(r_0\)</span>. Therefore lets assume the depolarizing noise channel will introduce an exponential decay to the approximate ratio of the form:</p>
<p><span class="math display">\[
r(p) = r_0(1 - e^{-\beta p}) + (1 - r_{0}e^{-\alpha p})e^{-\beta p},
\]</span></p>
<p>where I’ve introduced an additional rate term <span class="math inline">\(\beta\)</span> as the decay rate due to the polarzing noise, proportional to the system size <span class="math inline">\(n\)</span> and <span class="math inline">\(\lambda\)</span> through constant <span class="math inline">\(k\)</span>. We can determine the QAOA layer that maximizes this function <span class="math inline">\(p_{\text{max}}\)</span> through the first derivative, giving the result:</p>
<p><span class="math display">\[
p_{\text{max}} = \frac{1}{\alpha}\left(\ln\left(1+\frac{\alpha}{\lambda k n}\right)+\ln\left(\frac{r_0}{1-r_0}\right)\right).
\]</span></p>
<p>We can see that increasing the error probability <span class="math inline">\(\lambda\)</span> results in the approximate ratio reaching its maximum with fewer layers. Additionally, larger system sizes result in each QAOA layer to be deeper, and therefore decreases the number of layers before the maximum approximate ratio is reached.</p>
<p>Let us look at how the error rate <span class="math inline">\(\beta\)</span> must compare to the QAOA rate <span class="math inline">\(\alpha\)</span> in order to provide an approximate ratio that exceeds that of the Goemans-Williamson algorithm of <span class="math inline">\(r_{\text{GW}}\approx 0.9326\)</span> for 3-regular graphs (<span class="citation" data-cites="goemans1995improved">Goemans and Williamson (<a href="#ref-goemans1995improved" role="doc-biblioref">1995</a>)</span>). Define <span class="math inline">\(\gamma=\beta/\alpha\)</span> and we can allow <span class="math inline">\(r_0\approx0.5\)</span> as it should be for MaxCut problems, then the maximum approximate ratio acheived is:</p>
<p><span class="math display">\[
r_{\text{max}} = \frac{1}{2}\left(1+\frac{\gamma^\gamma}{(\gamma+1)^{\gamma+1}}\right).
\]</span></p>
<div id="cell-fig-rmax" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> r_max(x):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">1</span><span class="op">+</span>np.power(x,x)<span class="op">/</span>np.power(x<span class="op">+</span><span class="dv">1</span>,x<span class="op">+</span><span class="dv">1</span>))<span class="op">/</span><span class="fl">2.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>gammas <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">100</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>figsize)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r'</span><span class="dv">$</span><span class="er">\</span><span class="vs">gamma</span><span class="dv">$</span><span class="vs">'</span>, fontsize<span class="op">=</span>fontsize)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r'</span><span class="dv">$</span><span class="vs">r_{</span><span class="ch">\r</span><span class="vs">egular{max}}</span><span class="dv">$</span><span class="vs">'</span>, fontsize<span class="op">=</span>fontsize)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>ax.tick_params(axis<span class="op">=</span><span class="st">'both'</span>, labelsize<span class="op">=</span>ticksize)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>ax.plot(gammas, r_max(gammas), color<span class="op">=</span><span class="st">'black'</span>, lw<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="fl">0.9326</span>, ls<span class="op">=</span><span class="st">':'</span>, lw<span class="op">=</span><span class="dv">2</span>, color<span class="op">=</span><span class="st">'black'</span>, </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>           label<span class="op">=</span><span class="vs">r'</span><span class="dv">$</span><span class="vs">r_{</span><span class="ch">\r</span><span class="vs">egular{GW}}= 0</span><span class="dv">.</span><span class="vs">9326</span><span class="dv">$</span><span class="vs">'</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>ax.legend(framealpha<span class="op">=</span><span class="fl">0.</span>, fontsize<span class="op">=</span>fontsize)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-rmax" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rmax-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ionq_problems_files/figure-html/fig-rmax-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rmax-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Plot of the maximum approximate ratio <span class="math inline">\(r_{\text{max}}\)</span> over ratio of depolarizing to QAOA approximate ratio improvement rate <span class="math inline">\(\gamma\)</span>. With <span class="math inline">\(\gamma&lt;0.1\)</span> the <span class="math inline">\(r_{\text{max}}\)</span> exceeds that from the Goemans-Williamson bound of 0.87856.
</figcaption>
</figure>
</div>
</div>
</div>
<p>As seen in <a href="#fig-rmax" class="quarto-xref">Figure&nbsp;1</a>, with <span class="math inline">\(\gamma&lt;0.032\)</span>, we can beat the Goemans-Williamson bound. Taking <span class="math inline">\(\alpha=0.25\)</span> at <span class="math inline">\(n=20\)</span> from the <span class="citation" data-cites="zhou2020quantum">Zhou et al. (<a href="#ref-zhou2020quantum" role="doc-biblioref">2020</a>)</span> requires an error rate of <span class="math inline">\(k\lambda&lt;4\times10^{-4}\)</span> per gate.</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-aharonov2023polynomial" class="csl-entry" role="listitem">
Aharonov, Dorit, Xun Gao, Zeph Landau, Yunchao Liu, and Umesh Vazirani. 2023. <span>“A Polynomial-Time Classical Algorithm for Noisy Random Circuit Sampling.”</span> In <em>Proceedings of the 55th Annual ACM Symposium on Theory of Computing</em>, 945–57.
</div>
<div id="ref-andersen2025thermalization" class="csl-entry" role="listitem">
Andersen, Trond I, Nikita Astrakhantsev, Amir H Karamlou, Julia Berndtsson, Johannes Motruk, Aaron Szasz, Jonathan A Gross, et al. 2025. <span>“Thermalization and Criticality on an Analogue–Digital Quantum Simulator.”</span> <em>Nature</em> 638 (8049): 79–85.
</div>
<div id="ref-arute2019quantum" class="csl-entry" role="listitem">
Arute, Frank, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C Bardin, Rami Barends, Rupak Biswas, et al. 2019. <span>“Quantum Supremacy Using a Programmable Superconducting Processor.”</span> <em>Nature</em> 574 (7779): 505–10.
</div>
<div id="ref-assadi2025vizing" class="csl-entry" role="listitem">
Assadi, Sepehr, Soheil Behnezhad, Sayan Bhattacharya, Martı́n Costa, Shay Solomon, and Tianyi Zhang. 2025. <span>“Vizing’s Theorem in Near-Linear Time.”</span> In <em>Proceedings of the 57th Annual ACM Symposium on Theory of Computing</em>, 24–35.
</div>
<div id="ref-bluvstein2024logical" class="csl-entry" role="listitem">
Bluvstein, Dolev, Simon J Evered, Alexandra A Geim, Sophie H Li, Hengyun Zhou, Tom Manovitz, Sepehr Ebadi, et al. 2024. <span>“Logical Quantum Processor Based on Reconfigurable Atom Arrays.”</span> <em>Nature</em> 626 (7997): 58–65.
</div>
<div id="ref-cazals2025identifying" class="csl-entry" role="listitem">
Cazals, Pierre, Aymeric François, Loı̈c Henriet, Lucas Leclerc, Malory Marin, Yassine Naghmouchi, Wesley da Silva Coelho, et al. 2025. <span>“Identifying Hard Native Instances for the Maximum Independent Set Problem on Neutral Atoms Quantum Processors.”</span> <em>arXiv Preprint arXiv:2502.04291</em>.
</div>
<div id="ref-choi2016exploring" class="csl-entry" role="listitem">
Choi, Jae-yoon, Sebastian Hild, Johannes Zeiher, Peter Schauß, Antonio Rubio-Abadal, Tarik Yefsah, Vedika Khemani, David A Huse, Immanuel Bloch, and Christian Gross. 2016. <span>“Exploring the Many-Body Localization Transition in Two Dimensions.”</span> <em>Science</em> 352 (6293): 1547–52.
</div>
<div id="ref-cuthill1969reducing" class="csl-entry" role="listitem">
Cuthill, Elizabeth, and James McKee. 1969. <span>“Reducing the Bandwidth of Sparse Symmetric Matrices.”</span> In <em>Proceedings of the 1969 24th National Conference</em>, 157–72.
</div>
<div id="ref-decross2025computational" class="csl-entry" role="listitem">
DeCross, Matthew, Reza Haghshenas, Minzhao Liu, Enrico Rinaldi, Johnnie Gray, Yuri Alexeev, Charles H Baldwin, et al. 2025. <span>“Computational Power of Random Quantum Circuits in Arbitrary Geometries.”</span> <em>Physical Review X</em> 15 (2): 021052.
</div>
<div id="ref-farhi2014quantum" class="csl-entry" role="listitem">
Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. 2014. <span>“A Quantum Approximate Optimization Algorithm.”</span> <em>arXiv Preprint arXiv:1411.4028</em>.
</div>
<div id="ref-goemans1995improved" class="csl-entry" role="listitem">
Goemans, Michel X, and David P Williamson. 1995. <span>“Improved Approximation Algorithms for Maximum Cut and Satisfiability Problems Using Semidefinite Programming.”</span> <em>Journal of the ACM (JACM)</em> 42 (6): 1115–45.
</div>
<div id="ref-kim2023evidence" class="csl-entry" role="listitem">
Kim, Youngseok, Andrew Eddins, Sajant Anand, Ken Xuan Wei, Ewout Van Den Berg, Sami Rosenblatt, Hasan Nayfeh, et al. 2023. <span>“Evidence for the Utility of Quantum Computing Before Fault Tolerance.”</span> <em>Nature</em> 618 (7965): 500–505.
</div>
<div id="ref-king2024computational" class="csl-entry" role="listitem">
King, Andrew D, Alberto Nocera, Marek M Rams, Jacek Dziarmaga, Roeland Wiersema, William Bernoudy, Jack Raymond, et al. 2024. <span>“Computational Supremacy in Quantum Simulation.”</span> <em>arXiv Preprint arXiv:2403.00910</em>.
</div>
<div id="ref-morvan2024phase" class="csl-entry" role="listitem">
Morvan, Alexis, B Villalonga, X Mi, S Mandrà, A Bengtsson, PV Klimov, Z Chen, et al. 2024. <span>“Phase Transitions in Random Circuit Sampling.”</span> <em>Nature</em> 634 (8033): 328–33.
</div>
<div id="ref-peruzzo2014variational" class="csl-entry" role="listitem">
Peruzzo, Alberto, Jarrod McClean, Peter Shadbolt, Man-Hong Yung, Xiao-Qi Zhou, Peter J Love, Alán Aspuru-Guzik, and Jeremy L O’brien. 2014. <span>“A Variational Eigenvalue Solver on a Photonic Quantum Processor.”</span> <em>Nature Communications</em> 5 (1): 4213.
</div>
<div id="ref-yu2501quantum" class="csl-entry" role="listitem">
Yu, Jeffery, Javier Robledo Moreno, Joseph T Iosue, Luke Bertels, Daniel Claudino, Bryce Fuller, Peter Groszkowski, et al. 2025. <span>“Quantum-Centric Algorithm for Sample-Based Krylov Diagonalization.”</span> <em>arXiv Preprint arXiv:2501.09702</em>.
</div>
<div id="ref-zhou2020quantum" class="csl-entry" role="listitem">
Zhou, Leo, Sheng-Tao Wang, Soonwon Choi, Hannes Pichler, and Mikhail D Lukin. 2020. <span>“Quantum Approximate Optimization Algorithm: Performance, Mechanism, and Implementation on Near-Term Devices.”</span> <em>Physical Review X</em> 10 (2): 021067.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>